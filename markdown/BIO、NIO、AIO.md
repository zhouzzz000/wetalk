# BIO、NIO、AIO

## 阻塞与非阻塞

1. 线程访问资源，该资源是否准备就绪的一种处理方式

   1. 阻塞

      > 如果线程请求的资源没有准备就绪，该线程会等待该资源就绪，期间不会执行别的任务，直到该资源就绪的信号返回，线程才会继续执行下去

   2. 非阻塞

      > 如果线程请求的资源没有准备就绪,该线程会直接返回一个结果，不会等待该资源就绪的信号，继续执行别的任务

## 同步和异步

1. 同步和异步是指方法执行的一种机制

   1. 同步

      > 同步方法一旦开始，调用者必须等到方法执行完毕返回后，并获取返回值后，才能继续后续的行为

   2. 异步

      > 异步方法调用更像一个消息传递，一旦开始，调用者就会获得一个返回值，并不会等待调用方法执行完毕，可以继续后续的操作，而调用方法并没有执行完毕，直到方法执行完毕，会主动将返回值回调给调用者

## BIO（Block IO）

>  同步阻塞IO模型：用户线程调用内核进行IO操作时被阻塞
>
> 1. 用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间
> 2. 内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作
> 3. 再read发起IO和read完成返回这段时间内，用户线程被阻塞者无法执行别的任务

## NIO（Non-Block IO）

> 同步非阻塞IO模型：
>
> 1. 同步非阻塞IO是在同步阻塞IO的基础上，将socket设置为NIO(NONBLOCK)。
> 2. 由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回
> 3. 但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据

## IO多路复用

>IO多路复用模型：
>
>1. 在同步阻塞IO的基础上
>2. 区别于同步阻塞IO的是，未读取到数据时，用户线程并不是由于IO资源未就绪而阻塞，而是由于调用事件轮询线程select而阻塞。每个IO请求并不是创建新的系统线程来检查IO资源是否就绪，而是交由事件轮询线程select来检查哪个IO请求准备就绪，并将IO资源就绪的请求告诉给对应的用户 线程，用户线程发起真正的IO请求，并等待IO处理完毕返回
>3. 用户线程将IO请求添加到select中，然后阻塞系统等待select系统调用返回。当资源就绪时，socket被激活，select函数返回，用户线程正式发起read请求，读取资源并继续执行。

## AIO（异步非阻塞IO）

> 异步非阻塞IO模型：
>
> 1. 用户线程发起IO请求后立即返回，不等待IO就绪也不等待IO处理玩不
> 2. 系统内核处理完IO请求后主动返回结果给用户线程
> 3. 需要系统的支持